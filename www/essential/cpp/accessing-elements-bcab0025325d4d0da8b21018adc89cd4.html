<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="referrer" content="always">

  <meta name="twitter:card" value="summary">
  <meta name="twitter:site" content="@kjk">
  <meta name="twitter:title" content="Accessing Elements">
  
  <meta name="twitter:description" content="Accessing Elements">
  <meta name="twitter:creator" content="@kjk">
  <meta name="twitter:image" content="https://www.programming-books.io/covers/twitter/Cpp.png">
  
  <meta property="og:title" content="Accessing Elements">
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://www.programming-books.io/essential/cpp/accessing-elements-bcab0025325d4d0da8b21018adc89cd4" />
  
  <meta property="og:description" content="Accessing Elements">
  <meta property="og:image" content="https://www.programming-books.io/covers/twitter/Cpp.png">

  <title>std::vector / Accessing Elements / Essential C&#43;&#43;</title>
  <meta name="description" content="std::vector / Accessing Elements / Essential C&#43;&#43;">
  <link rel="icon" href="/s/favicon.ico">
  <link href="/s/main.css" rel="stylesheet">
  <link href="/s/bundle.css" rel="stylesheet">
  <script src="/s/app-cpp.js" defer></script>
  <script src="/s/bundle.js" defer></script>
</head>

<body class="page">
  <script>
  function onLoad() {
    gBookTitle = "Essential C\u002b\u002b";

    httpsMaybeRedirect();

    let opts = {
      target: document.getElementById("toc"),
      props: {
        parentIdx: -1,
        level: 0,
      },
    };
    new app.toc(opts);

    opts = {
      target: document.getElementById("search-parent"),
      props: {
        bookTitle: gBookTitle,
      },
    };
    new app.searchInput(opts);

    opts = {
      target: document.getElementById("page-toc"),
    };
    new app.pageToc(opts);

    opts = {
      target: document.getElementById("book-toc"),
    };
    new app.bookToc(opts);
  }
  document.addEventListener('DOMContentLoaded', onLoad);
</script>
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none">
  <symbol id="arrow-expanded" viewbox="0 0 16 16">
    <path fill="%23646465" d="M11 10H5.344L11 4.414V10z" />
  </symbol>

  <symbol id="arrow-not-expanded" viewbox="0 0 16 16">
    <path fill="%23646465" d="M6 4v8l4-4-4-4zm1 2.414L8.586 8 7 9.586V6.414z" />
  </symbol>

  <symbol id="icon-github" viewbox="0 0 496 512">
    <path
      d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" />
  </symbol>

  <symbol id="icon-home" viewbox="0 0 576 512">
    <path
      d="M488 312.7V456c0 13.3-10.7 24-24 24H348c-6.6 0-12-5.4-12-12V356c0-6.6-5.4-12-12-12h-72c-6.6 0-12 5.4-12 12v112c0 6.6-5.4 12-12 12H112c-13.3 0-24-10.7-24-24V312.7c0-3.6 1.6-7 4.4-9.3l188-154.8c4.4-3.6 10.8-3.6 15.3 0l188 154.8c2.7 2.3 4.3 5.7 4.3 9.3zm83.6-60.9L488 182.9V44.4c0-6.6-5.4-12-12-12h-56c-6.6 0-12 5.4-12 12V117l-89.5-73.7c-17.7-14.6-43.3-14.6-61 0L4.4 251.8c-5.1 4.2-5.8 11.8-1.6 16.9l25.5 31c4.2 5.1 11.8 5.8 16.9 1.6l235.2-193.7c4.4-3.6 10.8-3.6 15.3 0l235.2 193.7c5.1 4.2 12.7 3.5 16.9-1.6l25.5-31c4.2-5.2 3.4-12.7-1.7-16.9z" />
  </symbol>

  <symbol id="icon-twitter" viewbox="0 0 512 512">
    <path
      d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" />
  </symbol>

  <symbol id="icon-edit" viewbox="0 0 576 512">
    <path
      d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9l-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z" />
  </symbol>

  <symbol id="icon-star" viewbox="0 0 576 512">
    <path
      d="M528.1 171.5L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM388.6 312.3l23.7 138.4L288 385.4l-124.3 65.3 23.7-138.4-100.6-98 139-20.2 62.2-126 62.2 126 139 20.2-100.6 98z" />
  </symbol>
</svg>
  <header class="page__header">
  <div class="page__header__left">
    <a id="link-home" href="index.html">
      <svg class="icon-home">
        <use xlink:href="#icon-home"></use>
      </svg>
      &nbsp;Essential C&#43;&#43;</a>
  </div>
  <div class="page__header__center" id="search-parent">
  </div>
  <div class="page__header__right">
  </div>
</header>

  <div id="toc"></div>

  <div class="content">
    <div class="article">
      

<div style="display: flex; justify-content: space-between">
  <h1 class="title">Accessing Elements</h1>
  <a class="edit-link" style="font-size: 80%" href="https://notion.so/bcab0025325d4d0da8b21018adc89cd4" rel="nofollow"
  target="_blank">suggest change</a>
</div>


      
<p>There are two primary ways of accessing elements in a <a href="http://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>
</p>
  <ul id="facea50e-1c91-4293-a161-d8482897e53f" class="bulleted-list">
    <li>index-based access
    </li>
    <li><a href="/essential/cpp/iterators-ee86edbe8dd9497aa24cfa516272404e">iterators</a>
    </li>
  </ul>
  <h1 id="f8c1aaa8-f2c9-4f01-ae31-f6fce1cb1206" class="">Index-based access:
  <a class="header-anchor" href="#f8c1aaa8-f2c9-4f01-ae31-f6fce1cb1206" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5 0 1 0 .69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04 0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5 0 1 0-.5.88s.34.22.84.25c.5.03 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04 0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75l-1.5 1.5c-.78.78-.78 2.04 0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5 0 1 0-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04 0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5 0 1 0 .44-.88s-.34-.2-.84-.22z"></path></svg></a>
  </h1>
<p>This can be done either with the subscript operator <a href="http://en.cppreference.com/w/cpp/container/vector/operator_at"><code>[]</code></a>, or the member function <a href="http://en.cppreference.com/w/cpp/container/vector/at"><code>at()</code></a>.
</p>
<p>Both return a reference to the element at the respective position in the <code>std::vector</code> (unless it’s a <a href="http://stackoverflow.com/documentation/c%2B%2B/511/stdvector/2561/vectorbool-the-exception-to-many-many-rules#t=20160725190704070024"><code>vector&lt;bool&gt;</code></a>), so that it can be read as well as modified (if the vector is not <code>const</code>).
</p>
<p><code>[]</code> and <code>at()</code> differ in that <code>[]</code> is not guaranteed to perform any bounds checking, while <code>at()</code> does. Accessing elements where <code>index &lt; 0</code> or <code>index &gt;= size</code> is <a href="http://stackoverflow.com/documentation/c%2B%2B/1812/undefined-behavior#t=201607221823520289181">undefined behavior</a> for <code>[]</code>, while <code>at()</code> throws a <a href="http://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a> exception.
</p>
<p><em><strong>Note:</strong></em> The examples below use C++11-style initialization for clarity, but the operators can be used with all versions (unless marked C++11).
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="c1">// using []
</span><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">// a is 2
</span><span class="c1"></span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1">// v now contains { 1, 4, 3 }
</span><span class="c1"></span>
<span class="c1">// using at()
</span><span class="c1"></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// b is 3
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1">// v now contains { 1, 4, 5 }
</span><span class="c1"></span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// throws std::out_of_range exception
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Because the <code>at()</code> method performs bounds checking and can throw exceptions, it is slower than <code>[]</code>. This makes <code>[]</code> preferred code where the semantics of the operation guarantee that the index is in bounds. In any case, accesses to elements of vectors are done in constant time. That means accessing to the first element of the vector has the same cost (in time) of accessing the second element, the third element and so on.
</p>
<p>For example, consider this loop
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Here we know that the index variable <code>i</code> is always in bounds, so it would be a waste of CPU cycles to check that <code>i</code> is in bounds for every call to <code>operator[]</code>.
</p>
<p>The <a href="http://en.cppreference.com/w/cpp/container/vector/front"><code>front()</code></a> and <a href="http://en.cppreference.com/w/cpp/container/vector/back"><code>back()</code></a> member functions allow easy reference access to the first and last element of the vector, respectively. These positions are frequently used, and the special accessors can be more readable than their alternatives using <code>[]</code>:
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span> <span class="c1">// In pre-C++11 this is more verbose
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>   <span class="c1">// a is 4, v.front() is equivalent to v[0]
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1">// v now contains {3, 5, 6}
</span><span class="c1"></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>    <span class="c1">// b is 6, v.back() is equivalent to v[v.size() - 1]
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>        <span class="c1">// v now contains {3, 5, 7}
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p><em><strong>Note</strong></em>: It is <a href="http://stackoverflow.com/documentation/c%2B%2B/1812/undefined-behavior#t=201608052302241671564">undefined behavior</a> to invoke <code>front()</code> or <code>back()</code> on an empty vector. You need to check that the container is not empty using the <a href="http://en.cppreference.com/w/cpp/container/vector/empty"><code>empty()</code></a> member function (which checks if the container is empty) before calling <code>front()</code> or <code>back()</code>. A simple example of the use of ‘empty()’ to test for an empty vector follows:
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//create and initialize the vector
</span><span class="c1"></span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="c1">//loop through until the vector tests to be empty
</span><span class="c1"></span>  <span class="p">{</span>
     <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="c1">//keep a running total
</span><span class="c1"></span>     <span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span><span class="c1">//pop out the element which removes it from the vector
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;total: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="c1">//output the total to the user
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>The example above creates a vector with a sequence of numbers from 1 to 10. Then it pops the elements of the vector out until the vector is empty (using ‘empty()’) to prevent undefined behavior. Then the sum of the numbers in the vector is calculated and displayed to the user.
</p>
<p>The <a href="http://en.cppreference.com/w/cpp/container/vector/data"><code>data()</code></a> method returns a pointer to the raw memory used by the <code>std::vector</code> to internally store its elements. This is most often used when passing the vector data to legacy code that expects a C-style array.
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span> <span class="c1">// v contains {1, 2, 3, 4}
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// p points to 1
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>            <span class="c1">// v now contains {4, 2, 3, 4}
</span><span class="c1"></span><span class="o">++</span><span class="n">p</span><span class="p">;</span>               <span class="c1">// p points to 2
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>            <span class="c1">// v now contains {4, 3, 3, 4}
</span><span class="c1"></span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// v now contains {4, 3, 2, 4}
</span><span class="c1"></span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// v now contains {4, 3, 2, 1}
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Before C++11, the <code>data()</code> method can be simulated by calling <code>front()</code> and taking the address of the returned value:
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">());</span> <span class="c1">// or &amp;v[0]
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>This works because vectors are always guaranteed to store their elements in contiguous memory locations, assuming the contents of the vector doesn’t override unary <code>operator&amp;</code>. If it does, you’ll have to re-implement <a href="http://en.cppreference.com/w/cpp/memory/addressof"><code>std::addressof</code></a> in pre-C++11. It also assumes that the vector isn’t empty.
</p>
  <h1 id="0978c579-dd7a-4368-9203-07fdef0ad75d" class="">Iterators:
  <a class="header-anchor" href="#0978c579-dd7a-4368-9203-07fdef0ad75d" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5 0 1 0 .69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04 0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5 0 1 0-.5.88s.34.22.84.25c.5.03 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04 0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75l-1.5 1.5c-.78.78-.78 2.04 0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5 0 1 0-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04 0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5 0 1 0 .44-.88s-.34-.2-.84-.22z"></path></svg></a>
  </h1>
<p>Iterators are explained in more detail in the example “Iterating over <code>std::vector</code>” and the article <a href="https://stackoverflow.com/documentation/c%2B%2B/473/iterators/1709/overview#t=20160613174720948501">Iterators</a>. In short, they act similarly to pointers to the elements of the vector:
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>

<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>        <span class="c1">// i is 4
</span><span class="c1"></span><span class="o">++</span><span class="n">it</span><span class="p">;</span> 
<span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>            <span class="c1">// i is 5
</span><span class="c1"></span><span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>            <span class="c1">// v contains { 4, 6, 6 }
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>   <span class="c1">// e points to the element after the end of v. It can be 
</span><span class="c1"></span>                    <span class="c1">// used to check whether an iterator reached the end of the vector:
</span><span class="c1"></span><span class="o">++</span><span class="n">it</span><span class="p">;</span> 
<span class="n">it</span> <span class="o">==</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>      <span class="c1">// false, it points to the element at position 2 (with value 6)
</span><span class="c1"></span><span class="o">++</span><span class="n">it</span><span class="p">;</span>
<span class="n">it</span> <span class="o">==</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>      <span class="c1">// true
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>It is consistent with the standard that a <code>std::vector&lt;T&gt;</code>’s iterators actually <em>be</em> <code>T*</code>s, but most standard libraries do not do this. Not doing this both improves error messages, catches non-portable code, and can be used to instrument the iterators with debugging checks in non-release builds. Then, in release builds, the class wrapping around the underlying pointer is optimized away.
</p>
<p>You can persist a reference or a pointer to an element of a vector for indirect access. These references or pointers to elements in the <code>vector</code> remain stable and access remains defined unless you add/remove elements at or before the element in the <code>vector</code>, or you cause the <code>vector</code> capacity to change. This is the same as the rule for invalidating iterators.
</p>

<div class="code-box lang-C++">
	<div>
	<pre class="chroma"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">// p points to 2
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// p is now invalid, accessing *p is a undefined behavior.
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// p points to 1
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>             <span class="c1">// p is now invalid, accessing *p is a undefined behavior.
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// p points to 1
</span><span class="c1"></span><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>        <span class="c1">// p is now invalid, accessing *p is a undefined behavior.
</span></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>

      <div class="forum-link">
  Found a mistake? Have a question or improvement idea?
  <a href="#" onclick="showContact(); return false;">Let me know</a>.
</div>

      <form id="contact-form" action="https://formsubmit.co/kkowalczyk@gmail.com" method="POST">
  <p>
    <div class="contact-light">Feedback about page:</div>
    <input type="text" name="page-url" id="contact-page-url" readonly />
  </p>

  <p>
    <div class="contact-light">Feedback:</div>
    <textarea name="message" id="msg-for-chris"></textarea>
    <div class="contact-light">Optional: your email if you want me to get back to you: </div>
    <input type="email" name="email" />
    <input type="text" name="_honey" style="display:none">
  </p>

  <p>
    <button type="submit" class="contact-btn">
      Send Feedback
    </button>

    <button class="contact-btn" style="float: right;" onclick="hideContact(); return false;">
      Cancel
    </button>
  </p>

  <p>
    <div data-netlify-recaptcha></div>
  </p>
</form>


      <hr class="article-bottom-sep">
    </div>

    <div id="page-toc"></div>

    <div id="chapter-toc-wrapper">
      <hr />
      <div class="hdr">Table Of Contents</div>
      <div id="book-toc"></div>
    </div>
  </div>

  <footer class="page__footer">
  <div class="page__footer__left">
    Maintained by
    <a href="https://blog.kowalczyk.info" target="_blank">Krzysztof Kowalczyk</a>
  </div>
  <div class="share-me">
    <a href="https://twitter.com/intent/tweet?text=%22Essential%20C%2b%2b%22%20-%20a%20free%20programming%20book&url=https%3a%2f%2fwww.programming-books.io%2fessential%2fcpp%2f&via=kjk">Share
      <b>Essential C&#43;&#43;</b> on&nbsp;
      <svg class="icon-twitter">
        <use xlink:href="#icon-twitter"></use>
      </svg>
    </a>
  </div>
  <div class="page__footer__right">
    
  </div>
</footer>

  

</body>

</html>